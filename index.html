<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flavorz</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter (for a modern look) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Optional: A more decorative font for the splash screen if desired, e.g., 'Pacifico' or 'Sacramento' -->
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <!-- New: Google Fonts - Dancing Script for stylish tagline -->
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Hide scrollbar during splash screen */
        }
        /* Custom Styles for scrollbar in categories */
        .custom-scroll-y::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scroll-y::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .custom-scroll-y::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scroll-y::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Hidden by default for modals */
        .modal-overlay {
            display: none;
        }
        /* Style for the success message popup */
        .success-popup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #28a745; /* Green background */
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            font-weight: 500;
        }
        .success-popup.show {
            opacity: 1;
        }

        /* Custom keyframe for modal entry animation */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .modal-content-animated {
            animation: fadeInScale 0.3s ease-out forwards;
            position: absolute; /* Needed for transform origin to be center */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%; /* Ensure it's responsive */
            max-height: 90vh; /* Limit height */
            width: 100%; /* Take full width within max-width */
            overflow-y: auto; /* Enable scrolling for content */
        }

        /* Loading Spinner Animation */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .spinner {
            animation: spin 1s linear infinite;
        }

        /* Splash Screen Styles */
        #splash-screen {
            position: fixed;
            inset: 0; /* Top, right, bottom, left to 0 */
            /* UPDATED: More dynamic and vibrant gradient colors */
            background: linear-gradient(135deg, #FF7E5F, #FEB47B, #86A8E7, #91EAE4); /* Sunrise Orange -> Peach -> Light Blue -> Mint Green */
            background-size: 400% 400%; /* For dynamic gradient animation */
            animation: gradientShift 15s ease infinite; /* New: Gradient shift animation */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 1000; /* Ensure it's on top */
            opacity: 1;
            transition: opacity 1s ease-out; /* Fade out effect */
        }

        #splash-screen.fade-out {
            opacity: 0;
            pointer-events: none; /* Disable interaction during fade-out */
        }

        /* Keyframes for gradient background animation */
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .splash-title {
            font-family: 'Pacifico', cursive; /* Stylish font */
            font-size: 6rem; /* Larger font size */
            font-weight: 800;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.7), 0 0 35px rgba(255, 255, 255, 0.5); /* Enhanced shadow */
            background: linear-gradient(45deg, #FFFDE7, #FFECB3, #FFD700); /* Brighter golden gradient */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            animation: 
                splashTextAppear 1.5s ease-out forwards, /* Faster, more impactful appearance */
                splashTextPulse 2.5s ease-in-out infinite alternate; /* Continuous pulse */
            transform: scale(0.7); /* Start smaller for a more dramatic zoom */
            opacity: 0; /* Start invisible */
            margin-bottom: 20px;
        }

        /* Updated Splash Screen Tagline Style */
        .splash-tagline {
            font-family: 'Dancing Script', cursive; /* Stylish font for splash tagline */
            font-size: 2.8rem; /* Slightly larger tagline */
            font-weight: 700; /* Make it bolder */
            opacity: 0;
            transform: translateY(30px);
            animation: taglineFadeIn 1s ease-out 1.8s forwards;
            /* Add gradient color and shadow */
            background: linear-gradient(45deg, #FFDDC1, #FFABAB, #FFC3A0); /* Warm, inviting gradient */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3); /* Subtle shadow for depth */
        }

        @keyframes splashTextAppear {
            0% { opacity: 0; transform: scale(0.7) rotateX(-90deg); } /* Initial rotation for drama */
            50% { opacity: 1; transform: scale(1.1) rotateX(20deg); }
            100% { opacity: 1; transform: scale(1) rotateX(0deg); }
        }

        @keyframes splashTextPulse {
            0% { 
                transform: scale(1); 
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.7), 0 0 35px rgba(255, 255, 255, 0.5);
            }
            100% { 
                transform: scale(1.03); /* Subtle scale up */
                text-shadow: 0 0 25px rgba(255, 255, 255, 0.9), 0 0 45px rgba(255, 255, 255, 0.7); /* Brighter glow */
            }
        }

        @keyframes taglineFadeIn {
            to { opacity: 1; transform: translateY(0); }
        }

        /* Main App Title Styling */
        .main-title {
            font-family: 'Pacifico', cursive; /* Apply stylish font to main title too */
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            background: linear-gradient(to right, #a7e04f, #3cb371);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            /* Re-enhanced glowing animation for main title */
            animation: mainTitleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes mainTitleGlow {
            from {
                text-shadow: 0 0 8px rgba(167, 224, 79, 0.8), 0 0 15px rgba(60, 179, 113, 0.6);
            }
            to {
                text-shadow: 0 0 12px rgba(167, 224, 79, 1), 0 0 25px rgba(60, 179, 113, 0.8), 0 0 35px rgba(167, 224, 79, 0.4);
            }
        }

        /* New: Main App Tagline Style */
        .main-tagline {
            font-family: 'Dancing Script', cursive; /* Apply stylish font to main tagline */
            font-size: 1.8rem; /* Adjust size as needed for main page */
            font-weight: 700;
            background: linear-gradient(to right, #e74c3c, #f39c12); /* Vibrant gradient */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.2); /* Shadow for main page tagline */
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="splash-screen">
        <h1 class="splash-title">Flavorz</h1>
        <p class="splash-tagline">A world of tastes!</p>
    </div>

    <div id="root" style="display: none;"></div>
    <div id="popup-container"></div> <!-- Container for success/error popups -->

    <!-- Firebase JS SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js";
        import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, query, where } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-auth.js";

        window.firebase = {
            initializeApp: initializeApp,
            getFirestore: getFirestore,
            collection: collection,
            addDoc: addDoc,
            getDocs: getDocs,
            deleteDoc: deleteDoc,
            doc: doc,
            query: query,
            where: where,
            getAuth: getAuth,
            signInAnonymously: signInAnonymously,
            signInWithCustomToken: signInWithCustomToken,
            createUserWithEmailAndPassword: createUserWithEmailAndPassword,
            signInWithEmailAndPassword: signInWithEmailAndPassword,
            signOut: signOut,
            onAuthStateChanged: onAuthStateChanged
        };
    </script>

    <script>
        // Global variables provided by the environment (Canvas specific)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-recipe-app';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // TheMealDB API endpoints (direct calls, no CORS proxy needed)
        const MEALDB_API_BASE_URL = 'https://www.themealdb.com/api/json/v1/1/search.php?s=';
        const MEALDB_LOOKUP_URL = 'https://www.themealdb.com/api/json/v1/1/lookup.php?i=';
        const MEALDB_FILTER_CATEGORY_URL = 'https://www.themealdb.com/api/json/v1/1/filter.php?c=';
        const MEALDB_CATEGORIES_URL = 'https://www.themealdb.com/api/json/v1/1/categories.php';

        // Categories to display in the "Popular Dishes" section
        const POPULAR_DISH_CATEGORIES = ['Chicken', 'Beef', 'Dessert', 'Vegetarian', 'Seafood', 'Pasta'];
        const MAX_POPULAR_DISHES_TO_FETCH = 12; // Limit total popular dishes to display

        // Application State (global variables to simulate React state)
        let db = null;
        let auth = null;
        let firebaseUserId = null; 
        let currentUserIdForStorage = null; 
        let isAppInitialized = false;
        let isFirebaseEnabled = false; 

        let searchTerm = '';
        let recipes = [];
        let savedRecipes = [];
        let popularDishes = [];
        let categories = [];
        let loading = false;
        let error = null;
        let noResults = false;
        let activeTab = 'home'; 
        let selectedRecipe = null;
        let modalLoading = false;
        let modalError = null;

        // DOM elements (cached for efficiency)
        let rootDiv;
        let headerEl, errorDisplayEl; 
        let searchInputEl, searchButtonEl;
        let homeTabButton, searchTabButton, savedTabButton; 
        let popularDishesContainer, categoriesContainer;
        let dynamicContentContainer; 
        let initialSectionsWrapper; 
        let popupContainerEl; 

        // --- Utility Functions ---
        function showLoading(element, message = 'Loading...') {
            element.innerHTML = `
                <div class="flex flex-col items-center justify-center py-8 col-span-full text-gray-600">
                    <div class="spinner border-t-4 border-b-4 border-indigo-400 rounded-full w-12 h-12 mb-3"></div>
                    <p class="text-lg font-medium">${message}</p>
                </div>
            `;
        }

        function showError(element, message) {
            element.innerHTML = `
                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md relative mt-4 shadow-sm" role="alert">
                    <span class="block sm:inline">${message}</span>
                </div>
            `;
        }

        function showPopupMessage(message, type = 'success', duration = 3000) {
            if (!popupContainerEl) {
                popupContainerEl = document.getElementById('popup-container');
                if (!popupContainerEl) {
                    popupContainerEl = document.createElement('div');
                    popupContainerEl.id = 'popup-container';
                    document.body.appendChild(popupContainerEl);
                }
            }

            const popup = document.createElement('div');
            popup.className = `success-popup ${type === 'error' ? 'bg-red-500' : type === 'info' ? 'bg-blue-500' : 'bg-green-600'}`;
            popup.textContent = message;
            popupContainerEl.appendChild(popup);

            void popup.offsetWidth; 
            popup.classList.add('show');

            setTimeout(() => {
                popup.classList.remove('show');
                popup.addEventListener('transitionend', () => popup.remove(), { once: true });
            }, duration);
        }

        function shuffleArray(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        // --- Core Data Fetching Functions ---

        async function fetchRecipes(query, type = 'search') {
            loading = true;
            error = null;
            noResults = false;
            recipes = []; 
            renderDynamicContent(); 

            let url = '';
            let fetchedMealIds = [];

            try {
                if (type === 'search') {
                    url = `${MEALDB_API_BASE_URL}${encodeURIComponent(query)}`;
                    console.log(`Fetching recipes from: ${url}`);
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`HTTP error for ${url}: Status ${response.status}, Body: ${errorText}`);
                        throw new Error(`HTTP error! status: ${response.status} for URL: ${url}`);
                    }
                    const data = await response.json();
                    if (data.meals) {
                        recipes = data.meals;
                    } else {
                        noResults = true;
                    }
                } else if (type === 'category') {
                    url = `${MEALDB_FILTER_CATEGORY_URL}${encodeURIComponent(query)}`;
                    console.log(`Fetching meal IDs for category from: ${url}`);
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`HTTP error for ${url}: Status ${response.status}, Body: ${errorText}`);
                        throw new Error(`HTTP error! status: ${response.status} for URL: ${url}`);
                    }
                    const data = await response.json();
                    
                    if (data.meals) {
                        fetchedMealIds = data.meals.map(meal => meal.idMeal);
                        // Now fetch full details for each meal ID
                        const detailFetchPromises = fetchedMealIds.map(id => fetchRecipeDetailsById(id));
                        const results = await Promise.allSettled(detailFetchPromises);
                        
                        const fullRecipes = [];
                        results.forEach(result => {
                            if (result.status === 'fulfilled' && result.value) {
                                fullRecipes.push(result.value);
                            } else if (result.status === 'rejected') {
                                console.error(`Error fetching details for a meal ID from category:`, result.reason);
                            }
                        });
                        recipes = fullRecipes;
                    } else {
                        noResults = true;
                    }
                }
            } catch (err) {
                console.error('Error fetching recipes:', err);
                error = `Failed to fetch recipes: ${err.message}. This might be a network issue or TheMealDB API is unreachable.`;
            } finally {
                loading = false;
                renderDynamicContent(); 
                updateSectionVisibility(); 
            }
        }

        async function fetchRecipeDetails(id) {
            modalLoading = true;
            modalError = null;
            renderRecipeDetailModal(); 

            try {
                const url = `${MEALDB_LOOKUP_URL}${encodeURIComponent(id)}`;
                console.log(`Fetching recipe details from: ${url}`);
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`HTTP error for ${url}: Status ${response.status}, Body: ${errorText}`);
                    throw new Error(`HTTP error! status: ${response.status} for ID: ${id}`);
                }
                const data = await response.json();
                if (data.meals && data.meals.length > 0) {
                    selectedRecipe = data.meals[0];
                } else {
                    modalError = 'Recipe details not found.';
                }
            } catch (err) {
                console.error('Error fetching recipe details:', err);
                modalError = `Failed to load recipe details: ${err.message}. This might be a network issue or TheMealDB API is unreachable.`;
            } finally {
                modalLoading = false;
                renderRecipeDetailModal(); 
            }
        }

        async function fetchSavedRecipes() {
            loading = true;
            error = null;
            savedRecipes = [];
            renderDynamicContent(); 

            try {
                const localData = localStorage.getItem('localSavedRecipes');
                savedRecipes = localData ? JSON.parse(localData) : [];
                console.log("Loaded saved recipes from local storage.");
            } catch (err) {
                console.error("Error fetching saved recipes from local storage:", err);
                error = `Failed to load saved recipes from local storage: ${err.message}`;
            }
            updateSavedRecipesCount();
            loading = false;
            renderDynamicContent(); 
            updateSectionVisibility(); 
        }

        async function fetchPopularDishes() {
            loading = true; 
            error = null; 
            popularDishes = []; 
            renderPopularDishes(); 

            let allMealIds = new Set();
            let fetchedFullMeals = [];

            try {
                const categoryFetchPromises = POPULAR_DISH_CATEGORIES.map(category => {
                    const url = `${MEALDB_FILTER_CATEGORY_URL}${encodeURIComponent(category)}`;
                    console.log(`Fetching category dishes from: ${url}`);
                    return fetch(url)
                        .then(response => {
                            if (!response.ok) {
                                return response.text().then(errorText => {
                                    console.error(`HTTP error for category ${category}: Status ${response.status}, Body: ${errorText}`);
                                    throw new Error(`HTTP error! status: ${response.status} for category ${category}`);
                                });
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.meals && Array.isArray(data.meals)) {
                                data.meals.forEach(meal => allMealIds.add(meal.idMeal));
                            }
                        })
                        .catch(err => {
                            console.warn(`Could not fetch category ${category} for popular dishes:`, err);
                            return null;
                        });
                });

                await Promise.allSettled(categoryFetchPromises);

                const shuffledIds = shuffleArray(Array.from(allMealIds)).slice(0, MAX_POPULAR_DISHES_TO_FETCH);

                const detailFetchPromises = shuffledIds.map(id => fetchRecipeDetailsById(id));
                const results = await Promise.allSettled(detailFetchPromises);

                results.forEach(result => {
                    if (result.status === 'fulfilled' && result.value) {
                        fetchedFullMeals.push(result.value);
                    } else if (result.status === 'rejected') {
                        console.error(`Error fetching details for a popular meal ID:`, result.reason);
                    }
                });

                popularDishes = fetchedFullMeals;

            } catch (err) {
                console.error('Error in main fetchPopularDishes logic:', err);
                error = `Failed to load popular dishes: ${err.message}. This might be a network issue or TheMealDB API is unreachable.`;
                popularDishes = [];
            } finally {
                loading = false;
                renderPopularDishes(); 
                updateErrorDisplay();
                updateSectionVisibility(); 
            }
        }

        async function fetchRecipeDetailsById(id) {
            try {
                const url = `${MEALDB_LOOKUP_URL}${encodeURIComponent(id)}`;
                console.log(`Fetching individual meal details from: ${url}`);
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`HTTP error for meal ID ${id}: Status ${response.status}, Body: ${errorText}`);
                    throw new Error(`HTTP error! status: ${response.status} for meal ID ${id}`);
                }
                const data = await response.json();
                if (data.meals && data.meals.length > 0) {
                    return data.meals[0];
                }
                return null;
            } catch (err) {
                console.error(`Error fetching details for meal ID ${id}:`, err);
                throw err;
            }
        }

        async function fetchCategories() {
            loading = true; 
            error = null; 
            categories = []; 
            renderCategories(); 

            try {
                const url = `${MEALDB_CATEGORIES_URL}`;
                console.log(`Fetching categories from: ${url}`);
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`HTTP error for categories: Status ${response.status}, Body: ${errorText}`);
                    throw new Error(`HTTP error! status: ${response.status} for categories.`);
                }
                const data = await response.json();
                if (data.categories) {
                    categories = data.categories;
                }
            } catch (err) {
                console.error('Error fetching categories:', err);
                error = `Failed to fetch categories: ${err.message}. This might be a network issue or TheMealDB API is unreachable.`;
            } finally {
                loading = false;
                renderCategories(); 
                updateErrorDisplay();
                updateSectionVisibility(); 
            }
        }

        function triggerInitialDataFetches() {
            setTimeout(() => fetchPopularDishes(), 50);
            setTimeout(() => fetchCategories(), 150);
            setTimeout(() => fetchSavedRecipes(), 250);
        }
        
        async function saveRecipe(recipe) {
            const isAlreadySavedLocally = savedRecipes.some(saved => saved.idMeal === recipe.idMeal);
            if (isAlreadySavedLocally) {
                showPopupMessage("Recipe already saved locally!", 'info');
                return;
            }
            try {
                const newLocalRecipe = {
                    localId: Date.now().toString(36) + Math.random().toString(36).substring(2, 9), 
                    idMeal: recipe.idMeal,
                    strMeal: recipe.strMeal,
                    strMealThumb: recipe.strMealThumb,
                    strCategory: recipe.strCategory || 'N/A',
                    strArea: recipe.strArea || 'N/A',
                    savedAt: new Date().toISOString()
                };
                const updatedLocalRecipes = [...savedRecipes, newLocalRecipe];
                localStorage.setItem('localSavedRecipes', JSON.stringify(updatedLocalRecipes));
                showPopupMessage("Recipe saved successfully (local)!");
                fetchSavedRecipes(); 
            } catch (err) {
                console.error("Error saving recipe to local storage:", err);
                showPopupMessage(`Failed to save recipe locally: ${err.message}`, 'error');
            }
        }

        async function removeRecipe(identifierToRemove) { 
            try {
                const updatedLocalRecipes = savedRecipes.filter(recipe => recipe.localId !== identifierToRemove);
                localStorage.setItem('localSavedRecipes', JSON.stringify(updatedLocalRecipes));
                showPopupMessage("Recipe removed successfully (local)!");
                fetchSavedRecipes(); 
            } catch (err) {
                console.error("Error removing recipe from local storage:", err);
                showPopupMessage(`Failed to remove recipe locally: ${err.message}`, 'error');
            }
        }

        function openRecipeModal(recipeId) {
            fetchRecipeDetails(recipeId);
        }

        function closeRecipeModal() {
            selectedRecipe = null;
            modalError = null;
            modalLoading = false; 
            renderRecipeDetailModal();
        }

        // --- Event Handlers ---
        function handleSearch() {
            if (searchTerm.trim()) {
                activeTab = 'search'; 
                fetchRecipes(searchTerm, 'search');
            } else {
                error = "Please enter a recipe name to search.";
                updateErrorDisplay();
            }
        }

        function handleCategoryClick(categoryName) {
            searchTerm = ''; 
            activeTab = 'search'; 
            fetchRecipes(categoryName, 'category');
            updateSectionVisibility(); // Ensure sections visibility is updated
        }

        // --- UI Rendering Functions ---
        function renderApp() {
            if (!rootDiv) {
                rootDiv = document.getElementById('root');
                if (!rootDiv) {
                    rootDiv = document.createElement('div');
                    rootDiv.id = 'root';
                    document.body.appendChild(rootDiv);
                }
            }
            if (!popupContainerEl) {
                popupContainerEl = document.getElementById('popup-container');
                if (!popupContainerEl) {
                    popupContainerEl = document.createElement('div');
                    popupContainerEl.id = 'popup-container';
                    document.body.appendChild(popupContainerEl);
                }
            }
            
            // Only render main app content once it's initialized and splash screen fades
            if (isAppInitialized) {
                rootDiv.style.display = 'block'; // Make root visible
                rootDiv.className = "min-h-screen bg-gradient-to-br from-slate-800 to-neutral-900 p-4 sm:p-8 flex flex-col items-center";
                renderMainAppContent();
            } else {
                rootDiv.style.display = 'none'; // Keep root hidden initially
            }
        }

        function renderMainAppContent() {
            rootDiv.innerHTML = `
                <header class="w-full max-w-6xl text-white mb-8 flex flex-col items-center justify-center">
                    <h1 class="text-4xl sm:text-5xl font-extrabold mb-2 leading-tight main-title text-center">
                        Flavorz
                    </h1>
                    <p class="text-lg sm:text-xl font-light opacity-90 text-center main-tagline">A world of tastes!</p>
                    <div id="errorDisplay" class="mt-4"></div>
                </header>

                <div class="w-full max-w-full lg:max-w-7xl bg-white bg-opacity-90 rounded-2xl shadow-xl p-6 mb-8 mx-auto">
                    <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-6">
                        <input
                            type="text"
                            id="searchTermInput"
                            value="${searchTerm}"
                            placeholder="Search for a recipe (e.g., pasta, chicken)"
                            class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent text-gray-700 shadow-sm"
                        />
                        <button
                            id="searchButton"
                            class="w-full sm:w-auto px-6 py-3 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50 transition ease-in-out duration-150 shadow-md"
                        >
                            Search Recipes
                        </button>
                    </div>

                    <div class="flex justify-center space-x-4 mb-6">
                        <button
                            id="homeTabButton"
                            class="px-5 py-2 rounded-lg font-medium transition duration-200 ease-in-out ${activeTab === 'home' ? 'bg-indigo-500 text-white shadow-md' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}"
                        >
                            Home
                        </button>
                        <button
                            id="searchTabButton"
                            class="px-5 py-2 rounded-lg font-medium transition duration-200 ease-in-out ${activeTab === 'search' ? 'bg-indigo-500 text-white shadow-md' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}"
                        >
                            Search Results
                        </button>
                        <button
                            id="savedTabButton"
                            class="px-5 py-2 rounded-lg font-medium transition duration-200 ease-in-out ${activeTab === 'saved' ? 'bg-indigo-500 text-white shadow-md' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}"
                        >
                            My Saved Recipes (<span id="savedRecipesCount">${savedRecipes.length}</span>)
                        </button>
                    </div>

                    <div id="initialSectionsWrapper">
                        <h2 class="text-2xl font-bold text-gray-800 mb-4 mt-8 text-center">Browse Categories</h2>
                        <div id="categoriesContainer" class="flex flex-wrap justify-center gap-3 mb-8 max-h-48 overflow-y-auto p-2 rounded-lg bg-gray-100 custom-scroll-y shadow-inner"></div>
                        
                        <h2 class="text-2xl font-bold text-gray-800 mb-4 mt-8 text-center">Popular Dishes</h2>
                        <div id="popularDishesContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-4 gap-6 mb-8"></div>
                    </div>


                    <h2 class="text-2xl font-bold text-gray-800 mb-4 mt-8 text-center" id="dynamicContentTitle">
                        ${activeTab === 'search' ? 'Search & Category Results' : 'Your Saved Recipes'}
                    </h2>
                    <div id="dynamicContentContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-4 gap-6"></div>
                </div>

                <div id="recipeDetailModal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 overflow-y-auto"></div>
            `;

            // Cache DOM elements after initial render
            errorDisplayEl = document.getElementById('errorDisplay');
            searchTermInputEl = document.getElementById('searchTermInput');
            searchButtonEl = document.getElementById('searchButton');
            homeTabButton = document.getElementById('homeTabButton'); 
            searchTabButton = document.getElementById('searchTabButton');
            savedTabButton = document.getElementById('savedTabButton');
            popularDishesContainer = document.getElementById('popularDishesContainer');
            categoriesContainer = document.getElementById('categoriesContainer');
            dynamicContentContainer = document.getElementById('dynamicContentContainer');
            initialSectionsWrapper = document.getElementById('initialSectionsWrapper'); 

            // Set initial values
            if (error) showError(errorDisplayEl, error);

            // Add event listeners
            if (searchTermInputEl) {
                searchTermInputEl.addEventListener('input', (e) => {
                    searchTerm = e.target.value;
                });
                searchTermInputEl.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') handleSearch();
                });
            }
            if (searchButtonEl) searchButtonEl.addEventListener('click', handleSearch);
            if (homeTabButton) homeTabButton.addEventListener('click', () => { 
                activeTab = 'home'; 
                searchTerm = ''; 
                recipes = []; 
                noResults = false; 
                updateSectionVisibility(); 
                fetchPopularDishes(); 
                fetchCategories(); 
                renderApp(); 
            });
            if (searchTabButton) searchTabButton.addEventListener('click', () => {
                activeTab = 'search';
                if (searchTerm.trim() !== '') {
                     fetchRecipes(searchTerm, 'search');
                } else {
                    recipes = []; 
                    noResults = false; 
                    renderApp(); 
                }
                updateSectionVisibility(); 
            });
            if (savedTabButton) savedTabButton.addEventListener('click', () => {
                activeTab = 'saved';
                updateSectionVisibility(); 
                fetchSavedRecipes();
                renderApp(); 
            });

            // Render initial dynamic content
            renderPopularDishes();
            renderCategories();
            renderDynamicContent();
            updateSectionVisibility(); 

            // Render modal if selectedRecipe exists
            renderRecipeDetailModal();
        }


        function updateSectionVisibility() {
            if (initialSectionsWrapper) {
                if (activeTab === 'home') {
                    initialSectionsWrapper.style.display = 'block'; 
                } else {
                    initialSectionsWrapper.style.display = 'none'; 
                }
            }
            
            const buttons = [homeTabButton, searchTabButton, savedTabButton];
            buttons.forEach(button => {
                if (button) {
                    const buttonId = button.id.replace('TabButton', ''); 
                    const isActive = buttonId === activeTab;
                    
                    if (isActive) {
                        button.className = "px-5 py-2 rounded-lg font-medium transition duration-200 ease-in-out bg-indigo-500 text-white shadow-md";
                    } else {
                        button.className = "px-5 py-2 rounded-lg font-medium transition duration-200 ease-in-out bg-gray-200 text-gray-700 hover:bg-gray-300";
                    }
                }
            });
        }

        function updateErrorDisplay() {
            if (errorDisplayEl) {
                errorDisplayEl.innerHTML = ''; 
                if (error) {
                    showError(errorDisplayEl, error);
                }
            }
        }

        function updateSavedRecipesCount() {
            const savedRecipesCountEl = document.getElementById('savedRecipesCount');
            if (savedRecipesCountEl) {
                savedRecipesCountEl.textContent = savedRecipes.length;
            }
        }

        function renderPopularDishes() {
            if (initialSectionsWrapper && initialSectionsWrapper.style.display === 'block') {
                popularDishesContainer.innerHTML = '';
                if (loading && popularDishes.length === 0) {
                    showLoading(popularDishesContainer, "Loading popular dishes...");
                } else if (popularDishes.length > 0) {
                    popularDishes.forEach(recipe => {
                        popularDishesContainer.appendChild(createRecipeCard(recipe, true, false));
                    });
                } else if (!loading && error && error.includes("popular dishes")) {
                    popularDishesContainer.innerHTML = `<p class="text-center text-gray-600 font-medium col-span-full">${error}</p>`;
                } else if (!loading) {
                    popularDishesContainer.innerHTML = `<p class="text-center text-gray-600 font-medium col-span-full">No popular dishes found yet.</p>`;
                }
            } else {
                popularDishesContainer.innerHTML = ''; 
            }
        }

        function renderCategories() {
            if (initialSectionsWrapper && initialSectionsWrapper.style.display === 'block') {
                categoriesContainer.innerHTML = '';
                if (loading && categories.length === 0) {
                    showLoading(categoriesContainer, "Loading categories...");
                } else if (categories.length > 0) {
                    categories.forEach(category => {
                        const button = document.createElement('button');
                        button.className = "px-4 py-2 bg-emerald-600 text-white rounded-full text-sm font-semibold hover:bg-emerald-700 transition-colors shadow-sm";
                        button.textContent = category.strCategory;
                        button.addEventListener('click', () => handleCategoryClick(category.strCategory));
                        categoriesContainer.appendChild(button);
                    });
                } else if (!loading && error && error.includes("categories")) {
                    categoriesContainer.innerHTML = `<p class="text-center text-gray-600 text-sm">${error}</p>`;
                } else if (!loading) {
                    categoriesContainer.innerHTML = `<p class="text-center text-gray-600 text-sm">No categories found yet.</p>`;
                }
            } else {
                categoriesContainer.innerHTML = ''; 
            }
        }


        function renderDynamicContent() {
            const dynamicContentTitleEl = document.getElementById('dynamicContentTitle');
            if (dynamicContentTitleEl) {
                dynamicContentTitleEl.textContent = activeTab === 'search' ? 'Search & Category Results' : 'Your Saved Recipes';
            }
            dynamicContentContainer.innerHTML = ''; 

            if (loading) { 
                showLoading(dynamicContentContainer, "Loading recipes...");
            } else if (activeTab === 'search') {
                if (recipes.length > 0) {
                    recipes.forEach(recipe => {
                        dynamicContentContainer.appendChild(createRecipeCard(recipe, true, false));
                    });
                } else if (searchTerm.trim() !== '' && noResults) { 
                    dynamicContentContainer.innerHTML = `<p class="text-center text-gray-600 font-medium mb-4 col-span-full">No recipes found for "${searchTerm}". Try a different keyword or category!</p>`;
                } else { 
                    dynamicContentContainer.innerHTML = `<p class="text-center text-gray-600 font-medium mb-4 col-span-full text-lg">Start by searching for a recipe above or select a category from the Home tab!</p>`;
                }
            } else if (activeTab === 'saved') {
                updateSavedRecipesCount();
                if (savedRecipes.length > 0) {
                    savedRecipes.forEach(recipe => {
                        dynamicContentContainer.appendChild(createRecipeCard(recipe, true, true));
                    });
                } else {
                    dynamicContentContainer.innerHTML = `<p class="text-center text-gray-600 font-medium mb-4 col-span-full">You haven't saved any recipes yet!</p>`;
                }
            }
            updateErrorDisplay(); 
        }

        function createRecipeCard(recipe, showSave, showRemove) {
            const cardDiv = document.createElement('div');
            cardDiv.className = "bg-white rounded-xl shadow-lg overflow-hidden transform transition-transform duration-200 hover:scale-105 flex flex-col";

            const imageUrl = recipe.strMealThumb || `https://placehold.co/400x300/FDBA74/8B5CF6?text=No+Image`;

            cardDiv.innerHTML = `
                <img
                    src="${imageUrl}"
                    alt="${recipe.strMeal}"
                    class="w-full h-48 object-cover cursor-pointer"
                    onerror="this.onerror=null;this.src='https://placehold.co/400x300/FDBA74/8B5CF6?text=Image+Error';"
                />
                <div class="p-4 flex-grow flex flex-col justify-between">
                    <div>
                        <h2 class="text-xl font-bold text-gray-800 mb-2 leading-tight cursor-pointer hover:text-indigo-400 transition-colors">
                            ${recipe.strMeal}
                        </h2>
                        <p class="text-gray-600 text-sm">Category: ${recipe.strCategory || 'N/A'}</p>
                        <p class="text-gray-600 text-sm">Area: ${recipe.strArea || 'N/A'}</p>
                    </div>
                    <div class="mt-4 flex justify-end" id="actionButtons-${recipe.idMeal || recipe.localId}">
                        </div>
                </div>
            `;

            const imgEl = cardDiv.querySelector('img');
            if (imgEl) imgEl.addEventListener('click', () => openRecipeModal(recipe.idMeal));
            const titleEl = cardDiv.querySelector('h2');
            if (titleEl) titleEl.addEventListener('click', () => openRecipeModal(recipe.idMeal));

            const actionButtonsContainer = cardDiv.querySelector(`#actionButtons-${recipe.idMeal || recipe.localId}`);

            const isCurrentRecipeSaved = savedRecipes.some(saved => saved.idMeal === recipe.idMeal);

            if (showSave && !isCurrentRecipeSaved) {
                const saveButton = document.createElement('button');
                saveButton.className = "bg-green-500 text-white text-sm px-4 py-2 rounded-lg font-semibold hover:bg-green-600 transition-colors shadow-md";
                saveButton.textContent = "Save";
                saveButton.addEventListener('click', () => saveRecipe(recipe));
                actionButtonsContainer.appendChild(saveButton);
            } else if (showRemove && isCurrentRecipeSaved) {
                const removeButton = document.createElement('button');
                removeButton.className = "bg-red-500 text-white text-sm px-4 py-2 rounded-lg font-semibold hover:bg-red-600 transition-colors shadow-md";
                removeButton.textContent = "Remove";
                const recipeToRemove = savedRecipes.find(saved => saved.idMeal === recipe.idMeal);
                const identifierForRemoval = recipeToRemove.localId; 

                removeButton.addEventListener('click', () => removeRecipe(identifierForRemoval));
                actionButtonsContainer.appendChild(removeButton);
            } else if (showSave && isCurrentRecipeSaved) {
                const savedSpan = document.createElement('span');
                savedSpan.className = "text-gray-500 text-sm px-4 py-2";
                savedSpan.textContent = "Saved!";
                actionButtonsContainer.appendChild(savedSpan);
            }

            return cardDiv;
        }

        function renderRecipeDetailModal() {
            const modalEl = document.getElementById('recipeDetailModal');
            if (!modalEl) return;

            if (!selectedRecipe) {
                modalEl.style.display = 'none';
                modalEl.innerHTML = '';
                return;
            }

            modalEl.style.display = 'flex'; 

            if (modalLoading) {
                modalEl.innerHTML = `
                    <div class="bg-white rounded-xl p-8 max-w-xl w-full shadow-lg text-center modal-content-animated">
                        <p class="text-gray-700">Loading recipe details...</p>
                    </div>
                `;
                return;
            }

            if (modalError) {
                modalEl.innerHTML = `
                    <div class="bg-white rounded-xl p-8 max-w-xl w-full shadow-lg text-center modal-content-animated">
                        <p class="text-red-600">${modalError}</p>
                        <button id="modalCloseButton" class="mt-4 px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300">Close</button>
                    </div>
                `;
                document.getElementById('modalCloseButton').addEventListener('click', closeRecipeModal);
                return;
            }

            const ingredients = [];
            for (let i = 1; i <= 20; i++) {
                const ingredient = selectedRecipe[`strIngredient${i}`];
                const measure = selectedRecipe[`strMeasure${i}`];
                if (ingredient && ingredient.trim() && measure && measure.trim()) {
                    ingredients.push(`${measure.trim()} ${ingredient.trim()}`);
                }
            }

            const isCurrentRecipeSaved = savedRecipes.some(saved => selectedRecipe && saved.idMeal === selectedRecipe.idMeal);

            modalEl.innerHTML = `
                <div class="bg-white rounded-xl p-6 md:p-8 max-w-3xl w-full shadow-2xl relative flex flex-col max-h-[90vh] modal-content-animated">
                    <button
                        id="modalCloseButton"
                        class="absolute top-4 right-4 text-gray-500 hover:text-gray-700 transition-colors focus:outline-none"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>

                    <h2 class="text-3xl font-bold text-gray-800 mb-4">${selectedRecipe.strMeal}</h2>
                    <div class="flex flex-col md:flex-row gap-6 overflow-y-auto pr-2">
                        <div class="md:w-1/2 flex-shrink-0">
                            <img src="${selectedRecipe.strMealThumb}" alt="${selectedRecipe.strMeal}" class="w-full rounded-lg shadow-md mb-4 object-cover h-64" />
                            <p class="text-gray-700 mb-2"><span class="font-semibold">Category:</span> ${selectedRecipe.strCategory || 'N/A'}</p>
                            <p class="text-gray-700 mb-2"><span class="font-semibold">Area:</span> ${selectedRecipe.strArea || 'N/A'}</p>
                            ${selectedRecipe.strTags ? `<p class="text-gray-700 mb-2"><span class="font-semibold">Tags:</span> ${selectedRecipe.strTags.split(',').join(', ')}</p>` : ''}
                            ${selectedRecipe.strYoutube ? `
                                <a href="${selectedRecipe.strYoutube}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center text-red-600 hover:text-red-700 font-semibold mt-2 transition-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clipRule="evenodd" />
                                    </svg>
                                    Watch on YouTube
                                </a>
                            ` : ''}
                            <div class="mt-4" id="modalActionButtons">
                                </div>
                        </div>
                        <div class="md:w-1/2">
                            <h3 class="text-2xl font-semibold text-gray-800 mb-3">Ingredients</h3>
                            <ul class="list-disc list-inside text-gray-700 mb-6 space-y-1">
                                ${ingredients.length > 0 ? ingredients.map(item => `<li>${item}</li>`).join('') : '<li>No ingredients listed.</li>'}
                            </ul>
                            <h3 class="text-2xl font-semibold text-gray-800 mb-3">Instructions</h3>
                            <p class="text-gray-700 leading-relaxed whitespace-pre-line">
                                ${selectedRecipe.strInstructions || 'No instructions provided.'}
                            </p>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('modalCloseButton').addEventListener('click', closeRecipeModal);

            const modalActionButtons = document.getElementById('modalActionButtons');
            if (modalActionButtons) {
                if (!isCurrentRecipeSaved) {
                    const saveBtn = document.createElement('button');
                    saveBtn.className = "bg-green-600 text-white px-5 py-2 rounded-lg font-semibold hover:bg-green-700 transition-colors shadow-md";
                    saveBtn.textContent = "Save Recipe";
                    saveBtn.addEventListener('click', () => {
                        saveRecipe(selectedRecipe);
                        closeRecipeModal(); 
                    });
                    modalActionButtons.appendChild(saveBtn);
                } else {
                    const savedDoc = savedRecipes.find(saved => selectedRecipe && saved.idMeal === selectedRecipe.idMeal);
                    if (savedDoc) {
                        const removeBtn = document.createElement('button');
                        removeBtn.className = "bg-red-600 text-white px-5 py-2 rounded-lg font-semibold hover:bg-red-600 transition-colors shadow-md";
                        removeBtn.textContent = "Remove from Saved";
                        const identifierForRemoval = savedDoc.localId; 

                        removeBtn.addEventListener('click', () => removeRecipe(identifierForRemoval));
                        modalActionButtons.appendChild(removeBtn);
                    }
                }
            }
        }


        // --- Firebase/Local Storage and Data Fetching Logic ---

        async function initializeFirebaseAndAuth() {
            console.warn("Firebase authentication is disabled. Saved recipes will be managed via local storage.");
            db = null; 
            auth = null; 
            isFirebaseEnabled = false; 
            currentUserIdForStorage = 'local_user_' + Math.random().toString(36).substring(2, 9); 
            isAppInitialized = true; 
            // Call renderApp() which will now decide to show root or not based on isAppInitialized
            renderApp(); 
            triggerInitialDataFetches(); 
        }

        // --- Initialization ---
        window.onload = async () => {
            // Immediately show splash screen
            const splashScreen = document.getElementById('splash-screen');
            splashScreen.style.display = 'flex'; // Ensure splash screen is visible
            document.body.style.overflow = 'hidden'; // Prevent scrolling during splash

            // Initialize app data in the background
            await initializeFirebaseAndAuth();

            // After a delay, fade out splash screen and reveal main app
            setTimeout(() => {
                splashScreen.classList.add('fade-out');
                splashScreen.addEventListener('transitionend', () => {
                    splashScreen.style.display = 'none'; // Hide completely after fade
                    document.getElementById('root').style.display = 'block'; // Show main app
                    document.body.style.overflow = 'auto'; // Re-enable scrolling
                }, { once: true });
            }, 3000); // Display splash for 3 seconds
        };

    </script>
</body>
</html>
